// \brief     This is an AUTOMATICALLY GENERATED file for accumulating data
//            for an ellipsoidal fit for magnetometer calibration.
// \copyright Copyright (C) 2013 Ashima Research. All rights reserved. This
//            file distributed under the MIT Expat License. See LICENSE file.
//            https://github.com/ashima/AQ32Plus
// \remark    Do not edit this file by hand!
// \remark    Generated by genMcAccumulate.py

#include <inttypes.h>
#include <matDumb.h>


void mcCollectO( matrix<double, 9, 9> &OmegaTOmega,
                  matrix<double, 9, 1> &Omega1,
                  matrix<double,34, 1> &accOmega )
  {
  OmegaTOmega( 0, 0) = 1 * accOmega( 0,0) ; // xxxx
  OmegaTOmega( 0, 1) = 2 * accOmega( 1,0) ; // xxxy
  OmegaTOmega( 1, 1) = 4 * accOmega( 2,0) ; // xxyy
  OmegaTOmega( 0, 2) = 1 * accOmega( 2,0) ; // xxyy
  OmegaTOmega( 1, 2) = 2 * accOmega( 3,0) ; // xyyy
  OmegaTOmega( 2, 2) = 1 * accOmega( 4,0) ; // yyyy
  OmegaTOmega( 0, 3) = 2 * accOmega( 5,0) ; // xxxz
  OmegaTOmega( 1, 3) = 4 * accOmega( 6,0) ; // xxyz
  OmegaTOmega( 2, 3) = 2 * accOmega( 7,0) ; // xyyz
  OmegaTOmega( 3, 3) = 4 * accOmega( 9,0) ; // xxzz
  OmegaTOmega( 0, 4) = 2 * accOmega( 6,0) ; // xxyz
  OmegaTOmega( 1, 4) = 4 * accOmega( 7,0) ; // xyyz
  OmegaTOmega( 2, 4) = 2 * accOmega( 8,0) ; // yyyz
  OmegaTOmega( 3, 4) = 4 * accOmega(10,0) ; // xyzz
  OmegaTOmega( 4, 4) = 4 * accOmega(11,0) ; // yyzz
  OmegaTOmega( 0, 5) = 1 * accOmega( 9,0) ; // xxzz
  OmegaTOmega( 1, 5) = 2 * accOmega(10,0) ; // xyzz
  OmegaTOmega( 2, 5) = 1 * accOmega(11,0) ; // yyzz
  OmegaTOmega( 3, 5) = 2 * accOmega(12,0) ; // xzzz
  OmegaTOmega( 4, 5) = 2 * accOmega(13,0) ; // yzzz
  OmegaTOmega( 5, 5) = 1 * accOmega(14,0) ; // zzzz
  OmegaTOmega( 0, 6) = 2 * accOmega(15,0) ; // xxx
  OmegaTOmega( 1, 6) = 4 * accOmega(16,0) ; // xxy
  OmegaTOmega( 2, 6) = 2 * accOmega(17,0) ; // xyy
  OmegaTOmega( 3, 6) = 4 * accOmega(19,0) ; // xxz
  OmegaTOmega( 4, 6) = 4 * accOmega(20,0) ; // xyz
  OmegaTOmega( 5, 6) = 2 * accOmega(22,0) ; // xzz
  OmegaTOmega( 6, 6) = 4 * accOmega(25,0) ; // xx
  OmegaTOmega( 0, 7) = 2 * accOmega(16,0) ; // xxy
  OmegaTOmega( 1, 7) = 4 * accOmega(17,0) ; // xyy
  OmegaTOmega( 2, 7) = 2 * accOmega(18,0) ; // yyy
  OmegaTOmega( 3, 7) = 4 * accOmega(20,0) ; // xyz
  OmegaTOmega( 4, 7) = 4 * accOmega(21,0) ; // yyz
  OmegaTOmega( 5, 7) = 2 * accOmega(23,0) ; // yzz
  OmegaTOmega( 6, 7) = 4 * accOmega(26,0) ; // xy
  OmegaTOmega( 7, 7) = 4 * accOmega(27,0) ; // yy
  OmegaTOmega( 0, 8) = 2 * accOmega(19,0) ; // xxz
  OmegaTOmega( 1, 8) = 4 * accOmega(20,0) ; // xyz
  OmegaTOmega( 2, 8) = 2 * accOmega(21,0) ; // yyz
  OmegaTOmega( 3, 8) = 4 * accOmega(22,0) ; // xzz
  OmegaTOmega( 4, 8) = 4 * accOmega(23,0) ; // yzz
  OmegaTOmega( 5, 8) = 2 * accOmega(24,0) ; // zzz
  OmegaTOmega( 6, 8) = 4 * accOmega(28,0) ; // xz
  OmegaTOmega( 7, 8) = 4 * accOmega(29,0) ; // yz
  OmegaTOmega( 8, 8) = 4 * accOmega(30,0) ; // zz


  Omega1( 0,0) = 1 * accOmega(25,0); // xx
  Omega1( 1,0) = 2 * accOmega(26,0); // xy
  Omega1( 2,0) = 1 * accOmega(27,0); // yy
  Omega1( 3,0) = 2 * accOmega(28,0); // xz
  Omega1( 4,0) = 2 * accOmega(29,0); // yz
  Omega1( 5,0) = 1 * accOmega(30,0); // zz
  Omega1( 6,0) = 2 * accOmega(31,0); // x
  Omega1( 7,0) = 2 * accOmega(32,0); // y
  Omega1( 8,0) = 2 * accOmega(33,0); // z

  }


void mcAccumulate(matrix<double,34,1> &accOmega,
                  float x, float y, float z)
  {
  accOmega(33,0) += z ;
  accOmega(32,0) += y ;
  accOmega(31,0) += x ;
  accOmega(30,0) += z * z ;
  accOmega(29,0) += y * z ;
  accOmega(28,0) += x * z ;
  accOmega(27,0) += y * y ;
  accOmega(26,0) += x * y ;
  accOmega(25,0) += x * x ;
  accOmega(24,0) += z * z * z ;
  accOmega(23,0) += y * z * z ;
  accOmega(22,0) += x * z * z ;
  accOmega(21,0) += y * y * z ;
  accOmega(20,0) += x * y * z ;
  accOmega(19,0) += x * x * z ;
  accOmega(18,0) += y * y * y ;
  accOmega(17,0) += x * y * y ;
  accOmega(16,0) += x * x * y ;
  accOmega(15,0) += x * x * x ;
  accOmega(14,0) += z * z * z * z ;
  accOmega(13,0) += y * z * z * z ;
  accOmega(12,0) += x * z * z * z ;
  accOmega(11,0) += y * y * z * z ;
  accOmega(10,0) += x * y * z * z ;
  accOmega( 9,0) += x * x * z * z ;
  accOmega( 8,0) += y * y * y * z ;
  accOmega( 7,0) += x * y * y * z ;
  accOmega( 6,0) += x * x * y * z ;
  accOmega( 5,0) += x * x * x * z ;
  accOmega( 4,0) += y * y * y * y ;
  accOmega( 3,0) += x * y * y * y ;
  accOmega( 2,0) += x * x * y * y ;
  accOmega( 1,0) += x * x * x * y ;
  accOmega( 0,0) += x * x * x * x ;
  }


void mcCollectA( matrix<double, 3, 3> &A, matrix<double, 3, 1> &cp,
                  matrix<double, 9, 1> &u )
  {
  A( 0, 0) = u( 0,0); // xx
  A( 1, 0) = 
  A( 0, 1) = u( 1,0); // xy
  A( 1, 1) = u( 2,0); // yy
  A( 2, 0) = 
  A( 0, 2) = u( 3,0); // xz
  A( 2, 1) = 
  A( 1, 2) = u( 4,0); // yz
  A( 2, 2) = u( 5,0); // zz

  cp( 0,0) = u( 6,0); // x
  cp( 1,0) = u( 7,0); // y
  cp( 2,0) = u( 8,0); // z
  }

